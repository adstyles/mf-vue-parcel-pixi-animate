/**
 * @name json-variables
 * @fileoverview Resolves custom-marked, cross-referenced paths in parsed JSON
 * @version 11.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/json-variables/}
 */

var jsonVariables=(()=>{var or=Object.create;var q=Object.defineProperty,lr=Object.defineProperties,fr=Object.getOwnPropertyDescriptor,ur=Object.getOwnPropertyDescriptors,gr=Object.getOwnPropertyNames,Ke=Object.getOwnPropertySymbols,cr=Object.getPrototypeOf,Ue=Object.prototype.hasOwnProperty,hr=Object.prototype.propertyIsEnumerable;var me=(e,t,r)=>t in e?q(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,$=(e,t)=>{for(var r in t||(t={}))Ue.call(t,r)&&me(e,r,t[r]);if(Ke)for(var r of Ke(t))hr.call(t,r)&&me(e,r,t[r]);return e},K=(e,t)=>lr(e,ur(t)),Ge=e=>q(e,"__esModule",{value:!0});var we=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),pr=(e,t)=>{for(var r in t)q(e,r,{get:t[r],enumerable:!0})},ze=(e,t,r,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of gr(t))!Ue.call(e,o)&&(r||o!=="default")&&q(e,o,{get:()=>t[o],enumerable:!(i=fr(t,o))||i.enumerable});return e},U=(e,t)=>ze(Ge(q(e!=null?or(cr(e)):{},"default",!t&&e&&e.__esModule?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e),dr=(e=>(t,r)=>e&&e.get(t)||(r=ze(Ge({}),t,1),e&&e.set(t,r),r))(typeof WeakMap!="undefined"?new WeakMap:0);var be=(e,t,r)=>(me(e,typeof t!="symbol"?t+"":t,r),r);var Ce=we((Y,F)=>{var yr=200,Ye="__lodash_hash_undefined__",Xe=9007199254740991,Te="[object Arguments]",mr="[object Array]",Ze="[object Boolean]",Qe="[object Date]",wr="[object Error]",$e="[object Function]",et="[object GeneratorFunction]",te="[object Map]",tt="[object Number]",ve="[object Object]",rt="[object Promise]",nt="[object RegExp]",re="[object Set]",it="[object String]",st="[object Symbol]",Oe="[object WeakMap]",at="[object ArrayBuffer]",ne="[object DataView]",ot="[object Float32Array]",lt="[object Float64Array]",ft="[object Int8Array]",ut="[object Int16Array]",gt="[object Int32Array]",ct="[object Uint8Array]",ht="[object Uint8ClampedArray]",pt="[object Uint16Array]",dt="[object Uint32Array]",br=/[\\^$.*+?()[\]{}|]/g,Tr=/\w*$/,$r=/^\[object .+?Constructor\]$/,vr=/^(?:0|[1-9]\d*)$/,v={};v[Te]=v[mr]=v[at]=v[ne]=v[Ze]=v[Qe]=v[ot]=v[lt]=v[ft]=v[ut]=v[gt]=v[te]=v[tt]=v[ve]=v[nt]=v[re]=v[it]=v[st]=v[ct]=v[ht]=v[pt]=v[dt]=!0;v[wr]=v[$e]=v[Oe]=!1;var Or=typeof global=="object"&&global&&global.Object===Object&&global,_r=typeof self=="object"&&self&&self.Object===Object&&self,N=Or||_r||Function("return this")(),yt=typeof Y=="object"&&Y&&!Y.nodeType&&Y,mt=yt&&typeof F=="object"&&F&&!F.nodeType&&F,Ar=mt&&mt.exports===yt;function Ir(e,t){return e.set(t[0],t[1]),e}function Er(e,t){return e.add(t),e}function Sr(e,t){for(var r=-1,i=e?e.length:0;++r<i&&t(e[r],r,e)!==!1;);return e}function Wr(e,t){for(var r=-1,i=t.length,o=e.length;++r<i;)e[o+r]=t[r];return e}function wt(e,t,r,i){var o=-1,n=e?e.length:0;for(i&&n&&(r=e[++o]);++o<n;)r=t(r,e[o],o,e);return r}function Dr(e,t){for(var r=-1,i=Array(e);++r<e;)i[r]=t(r);return i}function Nr(e,t){return e==null?void 0:e[t]}function bt(e){var t=!1;if(e!=null&&typeof e.toString!="function")try{t=!!(e+"")}catch(r){}return t}function Tt(e){var t=-1,r=Array(e.size);return e.forEach(function(i,o){r[++t]=[o,i]}),r}function _e(e,t){return function(r){return e(t(r))}}function $t(e){var t=-1,r=Array(e.size);return e.forEach(function(i){r[++t]=i}),r}var xr=Array.prototype,Rr=Function.prototype,ie=Object.prototype,Ae=N["__core-js_shared__"],vt=function(){var e=/[^.]+$/.exec(Ae&&Ae.keys&&Ae.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}(),Ot=Rr.toString,R=ie.hasOwnProperty,se=ie.toString,Cr=RegExp("^"+Ot.call(R).replace(br,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),_t=Ar?N.Buffer:void 0,At=N.Symbol,It=N.Uint8Array,Vr=_e(Object.getPrototypeOf,Object),Hr=Object.create,jr=ie.propertyIsEnumerable,Mr=xr.splice,Et=Object.getOwnPropertySymbols,Pr=_t?_t.isBuffer:void 0,Jr=_e(Object.keys,Object),Ie=B(N,"DataView"),G=B(N,"Map"),Ee=B(N,"Promise"),Se=B(N,"Set"),We=B(N,"WeakMap"),z=B(Object,"create"),Br=M(Ie),Fr=M(G),kr=M(Ee),Lr=M(Se),qr=M(We),St=At?At.prototype:void 0,Wt=St?St.valueOf:void 0;function H(e){var t=-1,r=e?e.length:0;for(this.clear();++t<r;){var i=e[t];this.set(i[0],i[1])}}function Kr(){this.__data__=z?z(null):{}}function Ur(e){return this.has(e)&&delete this.__data__[e]}function Gr(e){var t=this.__data__;if(z){var r=t[e];return r===Ye?void 0:r}return R.call(t,e)?t[e]:void 0}function zr(e){var t=this.__data__;return z?t[e]!==void 0:R.call(t,e)}function Yr(e,t){var r=this.__data__;return r[e]=z&&t===void 0?Ye:t,this}H.prototype.clear=Kr;H.prototype.delete=Ur;H.prototype.get=Gr;H.prototype.has=zr;H.prototype.set=Yr;function x(e){var t=-1,r=e?e.length:0;for(this.clear();++t<r;){var i=e[t];this.set(i[0],i[1])}}function Xr(){this.__data__=[]}function Zr(e){var t=this.__data__,r=ae(t,e);if(r<0)return!1;var i=t.length-1;return r==i?t.pop():Mr.call(t,r,1),!0}function Qr(e){var t=this.__data__,r=ae(t,e);return r<0?void 0:t[r][1]}function en(e){return ae(this.__data__,e)>-1}function tn(e,t){var r=this.__data__,i=ae(r,e);return i<0?r.push([e,t]):r[i][1]=t,this}x.prototype.clear=Xr;x.prototype.delete=Zr;x.prototype.get=Qr;x.prototype.has=en;x.prototype.set=tn;function P(e){var t=-1,r=e?e.length:0;for(this.clear();++t<r;){var i=e[t];this.set(i[0],i[1])}}function rn(){this.__data__={hash:new H,map:new(G||x),string:new H}}function nn(e){return oe(this,e).delete(e)}function sn(e){return oe(this,e).get(e)}function an(e){return oe(this,e).has(e)}function on(e,t){return oe(this,e).set(e,t),this}P.prototype.clear=rn;P.prototype.delete=nn;P.prototype.get=sn;P.prototype.has=an;P.prototype.set=on;function J(e){this.__data__=new x(e)}function ln(){this.__data__=new x}function fn(e){return this.__data__.delete(e)}function un(e){return this.__data__.get(e)}function gn(e){return this.__data__.has(e)}function cn(e,t){var r=this.__data__;if(r instanceof x){var i=r.__data__;if(!G||i.length<yr-1)return i.push([e,t]),this;r=this.__data__=new P(i)}return r.set(e,t),this}J.prototype.clear=ln;J.prototype.delete=fn;J.prototype.get=un;J.prototype.has=gn;J.prototype.set=cn;function hn(e,t){var r=xe(e)||jn(e)?Dr(e.length,String):[],i=r.length,o=!!i;for(var n in e)(t||R.call(e,n))&&!(o&&(n=="length"||Rn(n,i)))&&r.push(n);return r}function Dt(e,t,r){var i=e[t];(!(R.call(e,t)&&Ct(i,r))||r===void 0&&!(t in e))&&(e[t]=r)}function ae(e,t){for(var r=e.length;r--;)if(Ct(e[r][0],t))return r;return-1}function pn(e,t){return e&&Nt(t,Re(t),e)}function De(e,t,r,i,o,n,l){var s;if(i&&(s=n?i(e,o,n,l):i(e)),s!==void 0)return s;if(!le(e))return e;var h=xe(e);if(h){if(s=Dn(e),!t)return En(e,s)}else{var a=j(e),g=a==$e||a==et;if(Pn(e))return Tn(e,t);if(a==ve||a==Te||g&&!n){if(bt(e))return n?e:{};if(s=Nn(g?{}:e),!t)return Sn(e,pn(s,e))}else{if(!v[a])return n?e:{};s=xn(e,a,De,t)}}l||(l=new J);var c=l.get(e);if(c)return c;if(l.set(e,s),!h)var T=r?Wn(e):Re(e);return Sr(T||e,function(m,u){T&&(u=m,m=e[u]),Dt(s,u,De(m,t,r,i,u,e,l))}),s}function dn(e){return le(e)?Hr(e):{}}function yn(e,t,r){var i=t(e);return xe(e)?i:Wr(i,r(e))}function mn(e){return se.call(e)}function wn(e){if(!le(e)||Vn(e))return!1;var t=Ht(e)||bt(e)?Cr:$r;return t.test(M(e))}function bn(e){if(!Rt(e))return Jr(e);var t=[];for(var r in Object(e))R.call(e,r)&&r!="constructor"&&t.push(r);return t}function Tn(e,t){if(t)return e.slice();var r=new e.constructor(e.length);return e.copy(r),r}function Ne(e){var t=new e.constructor(e.byteLength);return new It(t).set(new It(e)),t}function $n(e,t){var r=t?Ne(e.buffer):e.buffer;return new e.constructor(r,e.byteOffset,e.byteLength)}function vn(e,t,r){var i=t?r(Tt(e),!0):Tt(e);return wt(i,Ir,new e.constructor)}function On(e){var t=new e.constructor(e.source,Tr.exec(e));return t.lastIndex=e.lastIndex,t}function _n(e,t,r){var i=t?r($t(e),!0):$t(e);return wt(i,Er,new e.constructor)}function An(e){return Wt?Object(Wt.call(e)):{}}function In(e,t){var r=t?Ne(e.buffer):e.buffer;return new e.constructor(r,e.byteOffset,e.length)}function En(e,t){var r=-1,i=e.length;for(t||(t=Array(i));++r<i;)t[r]=e[r];return t}function Nt(e,t,r,i){r||(r={});for(var o=-1,n=t.length;++o<n;){var l=t[o],s=i?i(r[l],e[l],l,r,e):void 0;Dt(r,l,s===void 0?e[l]:s)}return r}function Sn(e,t){return Nt(e,xt(e),t)}function Wn(e){return yn(e,Re,xt)}function oe(e,t){var r=e.__data__;return Cn(t)?r[typeof t=="string"?"string":"hash"]:r.map}function B(e,t){var r=Nr(e,t);return wn(r)?r:void 0}var xt=Et?_e(Et,Object):Fn,j=mn;(Ie&&j(new Ie(new ArrayBuffer(1)))!=ne||G&&j(new G)!=te||Ee&&j(Ee.resolve())!=rt||Se&&j(new Se)!=re||We&&j(new We)!=Oe)&&(j=function(e){var t=se.call(e),r=t==ve?e.constructor:void 0,i=r?M(r):void 0;if(i)switch(i){case Br:return ne;case Fr:return te;case kr:return rt;case Lr:return re;case qr:return Oe}return t});function Dn(e){var t=e.length,r=e.constructor(t);return t&&typeof e[0]=="string"&&R.call(e,"index")&&(r.index=e.index,r.input=e.input),r}function Nn(e){return typeof e.constructor=="function"&&!Rt(e)?dn(Vr(e)):{}}function xn(e,t,r,i){var o=e.constructor;switch(t){case at:return Ne(e);case Ze:case Qe:return new o(+e);case ne:return $n(e,i);case ot:case lt:case ft:case ut:case gt:case ct:case ht:case pt:case dt:return In(e,i);case te:return vn(e,i,r);case tt:case it:return new o(e);case nt:return On(e);case re:return _n(e,i,r);case st:return An(e)}}function Rn(e,t){return t=t==null?Xe:t,!!t&&(typeof e=="number"||vr.test(e))&&e>-1&&e%1==0&&e<t}function Cn(e){var t=typeof e;return t=="string"||t=="number"||t=="symbol"||t=="boolean"?e!=="__proto__":e===null}function Vn(e){return!!vt&&vt in e}function Rt(e){var t=e&&e.constructor,r=typeof t=="function"&&t.prototype||ie;return e===r}function M(e){if(e!=null){try{return Ot.call(e)}catch(t){}try{return e+""}catch(t){}}return""}function Hn(e){return De(e,!0,!0)}function Ct(e,t){return e===t||e!==e&&t!==t}function jn(e){return Mn(e)&&R.call(e,"callee")&&(!jr.call(e,"callee")||se.call(e)==Te)}var xe=Array.isArray;function Vt(e){return e!=null&&Jn(e.length)&&!Ht(e)}function Mn(e){return Bn(e)&&Vt(e)}var Pn=Pr||kn;function Ht(e){var t=le(e)?se.call(e):"";return t==$e||t==et}function Jn(e){return typeof e=="number"&&e>-1&&e%1==0&&e<=Xe}function le(e){var t=typeof e;return!!e&&(t=="object"||t=="function")}function Bn(e){return!!e&&typeof e=="object"}function Re(e){return Vt(e)?hn(e):bn(e)}function Fn(){return[]}function kn(){return!1}F.exports=Hn});var Ve=we((Ai,Pt)=>{var Ln="[object Object]";function qn(e){var t=!1;if(e!=null&&typeof e.toString!="function")try{t=!!(e+"")}catch(r){}return t}function Kn(e,t){return function(r){return e(t(r))}}var Un=Function.prototype,jt=Object.prototype,Mt=Un.toString,Gn=jt.hasOwnProperty,zn=Mt.call(Object),Yn=jt.toString,Xn=Kn(Object.getPrototypeOf,Object);function Zn(e){return!!e&&typeof e=="object"}function Qn(e){if(!Zn(e)||Yn.call(e)!=Ln||qn(e))return!1;var t=Xn(e);if(t===null)return!0;var r=Gn.call(t,"constructor")&&t.constructor;return typeof r=="function"&&r instanceof r&&Mt.call(r)==zn}Pt.exports=Qn});var kt=we((Ft,ce)=>{(function(e,t){"use strict";typeof ce=="object"&&typeof ce.exports=="object"?ce.exports=t():typeof define=="function"&&define.amd?define([],t):e.objectPath=t()})(Ft,function(){"use strict";var e=Object.prototype.toString;function t(g,c){return g==null?!1:Object.prototype.hasOwnProperty.call(g,c)}function r(g){if(!g||n(g)&&g.length===0)return!0;if(typeof g!="string"){for(var c in g)if(t(g,c))return!1;return!0}return!1}function i(g){return e.call(g)}function o(g){return typeof g=="object"&&i(g)==="[object Object]"}var n=Array.isArray||function(g){return e.call(g)==="[object Array]"};function l(g){return typeof g=="boolean"||i(g)==="[object Boolean]"}function s(g){var c=parseInt(g);return c.toString()===g?c:g}function h(g){g=g||{};var c=function(d){return Object.keys(c).reduce(function(f,p){return p==="create"||typeof c[p]=="function"&&(f[p]=c[p].bind(c,d)),f},{})},T;g.includeInheritedProps?T=function(){return!0}:T=function(d,f){return typeof f=="number"&&Array.isArray(d)||t(d,f)};function m(d,f){if(T(d,f))return d[f]}var u;g.includeInheritedProps?u=function(d,f){typeof f!="string"&&typeof f!="number"&&(f=String(f));var p=m(d,f);if(f==="__proto__"||f==="prototype"||f==="constructor"&&typeof p=="function")throw new Error("For security reasons, object's magic properties cannot be set");return p}:u=function(d,f){return m(d,f)};function y(d,f,p,w){if(typeof f=="number"&&(f=[f]),!f||f.length===0)return d;if(typeof f=="string")return y(d,f.split(".").map(s),p,w);var b=f[0],O=u(d,b);return f.length===1?((O===void 0||!w)&&(d[b]=p),O):(O===void 0&&(typeof f[1]=="number"?d[b]=[]:d[b]={}),y(d[b],f.slice(1),p,w))}return c.has=function(d,f){if(typeof f=="number"?f=[f]:typeof f=="string"&&(f=f.split(".")),!f||f.length===0)return!!d;for(var p=0;p<f.length;p++){var w=s(f[p]);if(typeof w=="number"&&n(d)&&w<d.length||(g.includeInheritedProps?w in Object(d):t(d,w)))d=d[w];else return!1}return!0},c.ensureExists=function(d,f,p){return y(d,f,p,!0)},c.set=function(d,f,p,w){return y(d,f,p,w)},c.insert=function(d,f,p,w){var b=c.get(d,f);w=~~w,n(b)||(b=[],c.set(d,f,b)),b.splice(w,0,p)},c.empty=function(d,f){if(!r(f)&&d!=null){var p,w;if(!!(p=c.get(d,f))){if(typeof p=="string")return c.set(d,f,"");if(l(p))return c.set(d,f,!1);if(typeof p=="number")return c.set(d,f,0);if(n(p))p.length=0;else if(o(p))for(w in p)T(p,w)&&delete p[w];else return c.set(d,f,null)}}},c.push=function(d,f){var p=c.get(d,f);n(p)||(p=[],c.set(d,f,p)),p.push.apply(p,Array.prototype.slice.call(arguments,2))},c.coalesce=function(d,f,p){for(var w,b=0,O=f.length;b<O;b++)if((w=c.get(d,f[b]))!==void 0)return w;return p},c.get=function(d,f,p){if(typeof f=="number"&&(f=[f]),!f||f.length===0)return d;if(d==null)return p;if(typeof f=="string")return c.get(d,f.split("."),p);var w=s(f[0]),b=u(d,w);return b===void 0?p:f.length===1?b:c.get(d[w],f.slice(1),p)},c.del=function(f,p){if(typeof p=="number"&&(p=[p]),f==null||r(p))return f;if(typeof p=="string")return c.del(f,p.split("."));var w=s(p[0]);if(u(f,w),!T(f,w))return f;if(p.length===1)n(f)?f.splice(w,1):delete f[w];else return c.del(f[w],p.slice(1));return f},c}var a=h();return a.create=h,a.withInheritedProps=h({includeInheritedProps:!0}),a})});var Oi={};pr(Oi,{defaults:()=>rr,jVar:()=>vi,version:()=>pi});var fe=U(Ce(),1),Jt=U(Ve(),1);function ei(e){if(e.includes(".")){let t=e.lastIndexOf(".");if(!e.slice(0,t).includes("."))return e.slice(0,t);for(let r=t-1;r--;)if(e[r]===".")return e.slice(r+1,t)}return null}var He=ei;function ue(e,t){let r={now:!1};function i(o,n,l,s){let h=(0,fe.default)(o),a,g=$({depth:-1,path:""},l);if(g.depth+=1,Array.isArray(h))for(let c=0,T=h.length;c<T&&!s.now;c++){let m=g.path?`${g.path}.${c}`:`${c}`;h[c]!==void 0?(g.parent=(0,fe.default)(h),g.parentType="array",g.parentKey=He(m),a=i(n(h[c],void 0,K($({},g),{path:m}),s),n,K($({},g),{path:m}),s),Number.isNaN(a)&&c<h.length?(h.splice(c,1),c-=1):h[c]=a):h.splice(c,1)}else if((0,Jt.default)(h))for(let c in h){if(s.now&&c!=null)break;let T=g.path?`${g.path}.${c}`:c;g.depth===0&&c!=null&&(g.topmostKey=c),g.parent=(0,fe.default)(h),g.parentType="object",g.parentKey=He(T),a=i(n(c,h[c],K($({},g),{path:T}),s),n,K($({},g),{path:T}),s),Number.isNaN(a)?delete h[c]:h[c]=a}return h}return i(e,t,{},r)}function je(e){if(typeof e!="string")throw new TypeError("Expected a string");return e.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}var Me=new Map,Bt=(e,t)=>{if(!Array.isArray(e))switch(typeof e){case"string":e=[e];break;case"undefined":e=[];break;default:throw new TypeError(`Expected '${t}' to be a string or an array, but got a type of '${typeof e}'`)}return e.filter(r=>{if(typeof r!="string"){if(typeof r=="undefined")return!1;throw new TypeError(`Expected '${t}' to be an array of strings, but found a type of '${typeof r}' in the array`)}return!0})},ti=(e,t)=>{t=$({caseSensitive:!1},t);let r=e+JSON.stringify(t);if(Me.has(r))return Me.get(r);let i=e[0]==="!";i&&(e=e.slice(1)),e=je(e).replace(/\\\*/g,"[\\s\\S]*");let o=new RegExp(`^${e}$`,t.caseSensitive?"":"i");return o.negated=i,Me.set(r,o),o},ri=(e,t,r,i)=>{if(e=Bt(e,"inputs"),t=Bt(t,"patterns"),t.length===0)return[];t=t.map(l=>ti(l,r));let{allPatterns:o}=r||{},n=[];for(let l of e){let s,h=[...t].fill(!1);for(let[a,g]of t.entries())if(g.test(l)&&(h[a]=!0,s=!g.negated,!s))break;if(!(s===!1||s===void 0&&t.some(a=>!a.negated)||o&&h.some((a,g)=>!a&&!t[g].negated))&&(n.push(l),i))break}return n};function ge(e,t,r){return ri(e,t,r,!0).length>0}var D=U(kt(),1);function I(e){return typeof e=="string"?e.length?[e]:[]:e}function Lt(e){return e&&typeof e=="object"&&!Array.isArray(e)}function he(e){return typeof e=="string"}var qt={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1,hungry:!1},ni=e=>e+1;function ii(e,t,r,i,o=!1,n=ni){let l=typeof r=="function"?r():r;if(+t<0&&o&&l==="EOL")return l;let s=$($({},qt),i);if(t>=e.length&&!o)return!1;let h=o?1:r.length,a=0,g=!1,c=!1,T=!1,m=s.maxMismatches,u=t,y=!1,d=!1,f=!1;function p(){return a===1&&m<s.maxMismatches-1}for(;e[u];){let w=n(u);if(s.trimBeforeMatching&&e[u].trim()===""){if(!e[w]&&o&&r==="EOL")return!0;u=n(u);continue}if(s&&!s.i&&s.trimCharsBeforeMatching&&s.trimCharsBeforeMatching.includes(e[u])||(s==null?void 0:s.i)&&s.trimCharsBeforeMatching&&s.trimCharsBeforeMatching.map(O=>O.toLowerCase()).includes(e[u].toLowerCase())){if(o&&r==="EOL"&&!e[w])return!0;u=n(u);continue}let b=w>u?r[r.length-h]:r[h-1];if(!s.i&&e[u]===b||s.i&&e[u].toLowerCase()===b.toLowerCase()){if(y||(y=!0),T||(T=!0),h===r.length){if(d=!0,m!==s.maxMismatches)return!1}else h===1&&(f=!0);if(h-=1,a++,p())return!1;if(!h)return a!==r.length||m===s.maxMismatches||!g?u:!1}else if(!g&&!a&&(g=!0),s.maxMismatches&&m&&u){m-=1;for(let O=0;O<=m;O++){let E=w>u?r[r.length-h+1+O]:r[h-2-O],ye=e[n(u)];if(E&&(!s.i&&e[u]===E||s.i&&e[u].toLowerCase()===E.toLowerCase())&&(!s.firstMustMatch||h!==r.length)){if(a++,p())return!1;h-=2,y=!0;break}else if(ye&&E&&(!s.i&&ye===E||s.i&&ye.toLowerCase()===E.toLowerCase())&&(!s.firstMustMatch||h!==r.length)){if(!a&&!s.hungry)return!1;h-=1,y=!0;break}else if(E===void 0&&m>=0&&y&&(!s.firstMustMatch||d)&&(!s.lastMustMatch||f))return u}y||(c=u)}else return u===0&&h===1&&!s.lastMustMatch&&T?0:!1;if(c!==!1&&c!==u&&(c=!1),h<1)return u;u=n(u)}if(h>0)return o&&l==="EOL"?!0:s&&s.maxMismatches>=h&&T?c||0:!1}function Kt(e,t,r,i,o){if(Lt(o)&&Object.prototype.hasOwnProperty.call(o,"trimBeforeMatching")&&typeof o.trimBeforeMatching!="boolean")throw new Error(`string-match-left-right/${e}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(o.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);let n=$($({},qt),o);if(typeof n.trimCharsBeforeMatching=="string"&&(n.trimCharsBeforeMatching=I(n.trimCharsBeforeMatching)),n.trimCharsBeforeMatching=n.trimCharsBeforeMatching.map(g=>he(g)?g:String(g)),!he(t)||!t.length)return!1;if(!Number.isInteger(r)||r<0)throw new Error(`string-match-left-right/${e}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof r}, equal to:
${JSON.stringify(r,null,4)}`);let l,s;if(he(i))l=[i];else if(Array.isArray(i))l=i;else if(!i)l=i;else if(typeof i=="function")l=[],l.push(i);else throw new Error(`string-match-left-right/${e}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof i}, equal to:
${JSON.stringify(i,null,4)}`);if(o&&!Lt(o))throw new Error(`string-match-left-right/${e}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof o}", and equal to:
${JSON.stringify(o,null,4)}`);let h=0,a="";if((n==null?void 0:n.trimCharsBeforeMatching)&&n.trimCharsBeforeMatching.some((g,c)=>g.length>1?(h=c,a=g,!0):!1))throw new Error(`string-match-left-right/${e}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${h} is longer than 1 character, ${a.length} (equals to ${a}). Please split it into separate characters and put into array as separate elements.`);if(!l||!Array.isArray(l)||Array.isArray(l)&&!l.length||Array.isArray(l)&&l.length===1&&he(l[0])&&!l[0].trim()){if(typeof n.cb=="function"){let c,T=r;if((e==="matchLeftIncl"||e==="matchRight")&&(T+=1),e[5]==="L")for(let d=T;d--;){let f=t[d];if((!n.trimBeforeMatching||n.trimBeforeMatching&&f!==void 0&&f.trim())&&(!n.trimCharsBeforeMatching||!n.trimCharsBeforeMatching.length||f!==void 0&&!n.trimCharsBeforeMatching.includes(f))){c=d;break}}else if(e.startsWith("matchRight"))for(let d=T;d<t.length;d++){let f=t[d];if((!n.trimBeforeMatching||n.trimBeforeMatching&&f.trim())&&(!n.trimCharsBeforeMatching||!n.trimCharsBeforeMatching.length||!n.trimCharsBeforeMatching.includes(f))){c=d;break}}if(c===void 0)return!1;let m=t[c],u=c+1,y="";return u&&u>0&&(y=t.slice(0,u)),e[5]==="L"||c&&c>0&&(y=t.slice(c)),n.cb(m,y,c)}let g="";throw o||(g=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${e}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${g}`)}for(let g=0,c=l.length;g<c;g++){s=typeof l[g]=="function";let T=l[g],m,u,y="",d=r;e==="matchRight"?d+=1:e==="matchLeft"&&(d-=1);let f=ii(t,d,T,n,s,p=>e[5]==="L"?p-1:p+1);if(f&&s&&typeof T=="function"&&T()==="EOL")return T()&&(n.cb?n.cb(m,y,u):!0)?T():!1;if(Number.isInteger(f)&&(u=e.startsWith("matchLeft")?f-1:f+1,e[5]==="L"?y=t.slice(0,f):y=t.slice(u)),u<0&&(u=void 0),t[u]&&(m=t[u]),Number.isInteger(f)&&(n.cb?n.cb(m,y,u):!0))return T}return!1}function k(e,t,r,i){return Kt("matchLeftIncl",e,t,r,i)}function W(e,t,r,i){return Kt("matchRightIncl",e,t,r,i)}function si(e){return e&&typeof e=="object"&&!Array.isArray(e)}function S(e){return typeof e=="string"}var Ut={fromIndex:0,throwWhenSomethingWrongIsDetected:!0,allowWholeValueToBeOnlyHeadsOrTails:!0,source:"string-find-heads-tails",matchHeadsAndTailsStrictlyInPairsByTheirOrder:!1,relaxedAPI:!1};function Pe(e,t,r,i){if(i&&!si(i))throw new TypeError(`string-find-heads-tails: [THROW_ID_01] the fourth input argument, an Optional Options Object, must be a plain object! Currently it's equal to: ${i} (type: ${typeof i})`);let o=$($({},Ut),i);if(typeof o.fromIndex=="string"&&/^\d*$/.test(o.fromIndex))o.fromIndex=Number(o.fromIndex);else if(!Number.isInteger(o.fromIndex)||o.fromIndex<0)throw new TypeError(`${o.source} [THROW_ID_18] the fourth input argument must be a natural number or zero! Currently it's: ${o.fromIndex}`);if(!S(e)||e.length===0){if(o.relaxedAPI)return[];throw new TypeError(`string-find-heads-tails: [THROW_ID_02] the first input argument, input string, must be a non-zero-length string! Currently it's: ${typeof e}, equal to: ${e}`)}let n,l;if(typeof t!="string"&&!Array.isArray(t)){if(o.relaxedAPI)return[];throw new TypeError(`string-find-heads-tails: [THROW_ID_03] the second input argument, heads, must be either a string or an array of strings! Currently it's: ${typeof t}, equal to:
${JSON.stringify(t,null,4)}`)}else if(typeof t=="string")if(t.length===0){if(o.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_04] the second input argument, heads, must be a non-empty string! Currently it's empty.")}else t=I(t);else if(Array.isArray(t))if(t.length===0){if(o.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_05] the second input argument, heads, must be a non-empty array and contain at least one string! Currently it's empty.")}else if(t.every((u,y)=>(n=u,l=y,S(u)))){if(!t.every((u,y)=>(l=y,S(u)&&u.length>0&&u.trim()!=="")))if(o.relaxedAPI){if(t=t.filter(u=>S(u)&&u.length>0),t.length===0)return[]}else throw new TypeError(`string-find-heads-tails: [THROW_ID_07] the second input argument, heads, should not contain empty strings! For example, there's one detected at index ${l} of heads array:
${JSON.stringify(t,null,4)}.`)}else if(o.relaxedAPI){if(t=t.filter(u=>S(u)&&u.length>0),t.length===0)return[]}else throw new TypeError(`string-find-heads-tails: [THROW_ID_06] the second input argument, heads, contains non-string elements! For example, element at ${l}th index is ${typeof n}, equal to:
${JSON.stringify(n,null,4)}. Whole heads array looks like:
${JSON.stringify(t,null,4)}`);if(!S(r)&&!Array.isArray(r)){if(o.relaxedAPI)return[];throw new TypeError(`string-find-heads-tails: [THROW_ID_08] the third input argument, tails, must be either a string or an array of strings! Currently it's: ${typeof r}, equal to:
${JSON.stringify(r,null,4)}`)}else if(S(r))if(r.length===0){if(o.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_09] the third input argument, tails, must be a non-empty string! Currently it's empty.")}else r=I(r);else if(Array.isArray(r))if(r.length===0){if(o.relaxedAPI)return[];throw new TypeError("string-find-heads-tails: [THROW_ID_10] the third input argument, tails, must be a non-empty array and contain at least one string! Currently it's empty.")}else if(r.every((u,y)=>(n=u,l=y,S(u)))){if(!r.every((u,y)=>(l=y,S(u)&&u.length>0&&u.trim()!=="")))if(o.relaxedAPI){if(r=r.filter(u=>S(u)&&u.length>0),r.length===0)return[]}else throw new TypeError(`string-find-heads-tails: [THROW_ID_12] the third input argument, tails, should not contain empty strings! For example, there's one detected at index ${l}. Whole tails array is equal to:
${JSON.stringify(r,null,4)}`)}else if(o.relaxedAPI){if(r=r.filter(u=>S(u)&&u.length>0),r.length===0)return[]}else throw new TypeError(`string-find-heads-tails: [THROW_ID_11] the third input argument, tails, contains non-string elements! For example, element at ${l}th index is ${typeof n}, equal to:
${JSON.stringify(n,null,4)}. Whole tails array is equal to:
${JSON.stringify(r,null,4)}`);let s=o.source===Ut.source;if(o.throwWhenSomethingWrongIsDetected&&!o.allowWholeValueToBeOnlyHeadsOrTails){if(I(t).includes(e))throw new Error(`${o.source}${s?": [THROW_ID_16]":""} the whole input string can't be equal to ${S(t)?"":"one of "}heads (${e})!`);if(I(r).includes(e))throw new Error(`${o.source}${s?": [THROW_ID_17]":""} the whole input string can't be equal to ${S(r)?"":"one of "}tails (${e})!`)}let h=t.concat(r).map(u=>u.charAt(0)).reduce((u,y)=>y.charCodeAt(0)>u[1]?[u[0],y.charCodeAt(0)]:y.charCodeAt(0)<u[0]?[y.charCodeAt(0),u[1]]:u,[t[0].charCodeAt(0),t[0].charCodeAt(0)]),a=[],g=!1,c={},T="",m;for(let u=o.fromIndex,y=e.length;u<y;u++){let d=e[u].charCodeAt(0);if(d<=h[1]&&d>=h[0]){let f=W(e,u,t);if(f&&o.matchHeadsAndTailsStrictlyInPairsByTheirOrder){for(let w=t.length;w--;)if(t[w]===f){m=w;break}}if(typeof f=="string")if(g){if(o.throwWhenSomethingWrongIsDetected)throw new TypeError(`${o.source}${s?": [THROW_ID_19]":""} When processing "${e}", we found heads (${e.slice(u,u+f.length)}) starting at character with index number "${u}" and there was another set of heads before it! Generally speaking, there should be "heads-tails-heads-tails", not "heads-heads-tails"!
We're talking about the area of the code:


--------------------------------------starts
${e.slice(Math.max(u-200,0),u)}
      ${`[${33}m------->[${39}m`} ${`[${31}m${e.slice(u,u+f.length)}[${39}m`} [${33}m<-------[${39}m
${e.slice(u+f.length,Math.min(y,u+200))}
--------------------------------------ends


To turn off this error being thrown, set opts.throwWhenSomethingWrongIsDetected to Boolean false.`)}else{c={},c.headsStartAt=u,c.headsEndAt=u+f.length,g=!0,u+=f.length-1,T&&(T="");continue}let p=W(e,u,r);if(g&&p&&o.matchHeadsAndTailsStrictlyInPairsByTheirOrder&&m!==void 0&&r[m]!==void 0&&r[m]!==p){let w;for(let b=r.length;b--;)if(r[b]===p){w=b;break}throw new TypeError(`${o.source}${s?": [THROW_ID_20]":""} When processing "${e}", we had "opts.matchHeadsAndTailsStrictlyInPairsByTheirOrder" on. We found heads (${t[m]}) but the tails the followed it were not of the same index, ${m} (${r[m]}) but ${w} (${p}).`)}if(typeof p=="string")if(g){c.tailsStartAt=u,c.tailsEndAt=u+p.length,a.push(c),c={},g=!1,u+=p.length-1;continue}else o.throwWhenSomethingWrongIsDetected&&(T=`${o.source}${s?": [THROW_ID_21]":""} When processing "${e}", we found tails (${e.slice(u,u+p.length)}) starting at character with index number "${u}" but there were no heads preceding it. That's very naughty!`)}if(o.throwWhenSomethingWrongIsDetected&&u===y-1){if(Object.keys(c).length!==0)throw new TypeError(`${o.source}${s?": [THROW_ID_22]":""} When processing "${e}", we reached the end of the string and yet didn't find any tails (${JSON.stringify(r,null,4)}) to match the last detected heads (${e.slice(c.headsStartAt,c.headsEndAt)})!`);if(T)throw new Error(T)}}return a}var Je=U(Ce(),1);function Be(e,t,r){let i;r!==void 0&&(i=Array.isArray(r)?(0,Je.default)(r):[(0,Je.default)(r)]);let o=[],n=ue(e,(l,s,h)=>{let a=s!==void 0?s:l;if(s!==void 0&&ge(l,t,{caseSensitive:!0})){if(i===void 0)o.push({val:s,path:h.path});else if(i.length)return i.shift()}return a});return i===void 0?o:n}function pe(e,t=1){let r="\xA0";function i(n){return Array.from(n).reverse().join("")}function o(n,l,s){let h=s?`
`:"\r",a=s?"\r":`
`;if(!n)return n;let g=0,c=0,T="";for(let m=0,u=n.length;m<u;m++)(n[m]===h||n[m]===a&&n[m-1]!==h)&&c++,`\r
`.includes(n[m])||n[m]===r?(g=0,n[m]===r?T+=n[m]:n[m]===h?c<=l&&(T+=n[m],n[m+1]===a&&(T+=n[m+1],m++)):n[m]===a&&(!n[m-1]||n[m-1]!==h)&&c<=l&&(T+=n[m])):(g++,!n[m+1]&&!c&&(T+=" "));return T}if(typeof e=="string"&&e.length){let n=1;typeof+t=="number"&&Number.isInteger(+t)&&+t>=0&&(n=+t);let l="",s="";if(!e.trim())l=e;else if(!e[0].trim()){for(let h=0,a=e.length;h<a;h++)if(e[h].trim()){l=e.slice(0,h);break}}if(e.trim()&&(e.slice(-1).trim()===""||e.slice(-1)===r)){for(let h=e.length;h--;)if(e[h].trim()){s=e.slice(h+1);break}}return`${o(l,n,!1)}${e.trim()}${i(o(i(s),n,!0))}`}return e}var ai={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function Gt(e,t){if(!Array.isArray(e)||!e.length)return e;let r=$($({},ai),t),i,o;if(r.strictlyTwoElementsInRangeArrays&&!e.every((s,h)=>!Array.isArray(s)||s.length!==2?(i=h,o=s.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${i}th range (${JSON.stringify(e[i],null,4)}) has not two but ${o} elements!`);if(!e.every((s,h)=>!Array.isArray(s)||!Number.isInteger(s[0])||s[0]<0||!Number.isInteger(s[1])||s[1]<0?(i=h,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${i}th range (${JSON.stringify(e[i],null,4)}) does not consist of only natural numbers!`);let n=e.length**2,l=0;return Array.from(e).sort((s,h)=>(r.progressFn&&(l+=1,r.progressFn(Math.floor(l*100/n))),s[0]===h[0]?s[1]<h[1]?-1:s[1]>h[1]?1:0:s[0]<h[0]?-1:1))}var zt={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function oi(e,t){function r(a){return a&&typeof a=="object"&&!Array.isArray(a)}if(!Array.isArray(e)||!e.length)return null;let i;if(t)if(r(t)){if(i=$($({},zt),t),i.progressFn&&r(i.progressFn)&&!Object.keys(i.progressFn).length)i.progressFn=null;else if(i.progressFn&&typeof i.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof i.progressFn}", equal to ${JSON.stringify(i.progressFn,null,4)}`);if(![1,2,"1","2"].includes(i.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof i.mergeType}", equal to ${JSON.stringify(i.mergeType,null,4)}`);if(typeof i.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof i.joinRangesThatTouchEdges}", equal to ${JSON.stringify(i.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(t,null,4)} (type ${typeof t})`);else i=$({},zt);let o=e.filter(a=>Array.isArray(a)).map(a=>[...a]).filter(a=>a[2]!==void 0||a[0]!==a[1]),n,l,s;i.progressFn?n=Gt(o,{progressFn:a=>{s=Math.floor(a/5),s!==l&&(l=s,i.progressFn(s))}}):n=Gt(o);let h=n.length-1;for(let a=h;a>0;a--)i.progressFn&&(s=Math.floor((1-a/h)*78)+21,s!==l&&s>l&&(l=s,i.progressFn(s))),(n[a][0]<=n[a-1][0]||!i.joinRangesThatTouchEdges&&n[a][0]<n[a-1][1]||i.joinRangesThatTouchEdges&&n[a][0]<=n[a-1][1])&&(n[a-1][0]=Math.min(n[a][0],n[a-1][0]),n[a-1][1]=Math.max(n[a][1],n[a-1][1]),n[a][2]!==void 0&&(n[a-1][0]>=n[a][0]||n[a-1][1]<=n[a][1])&&n[a-1][2]!==null&&(n[a][2]===null&&n[a-1][2]!==null?n[a-1][2]=null:n[a-1][2]!=null?+i.mergeType==2&&n[a-1][0]===n[a][0]?n[a-1][2]=n[a][2]:n[a-1][2]+=n[a][2]:n[a-1][2]=n[a][2]),n.splice(a,1),a=n.length);return n.length?n:null}function C(e){return e!=null}function V(e){return Number.isInteger(e)&&e>=0}function X(e){return typeof e=="string"}var li={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},Z=class{constructor(e){be(this,"ranges");be(this,"opts");let t=$($({},li),e);if(t.mergeType&&t.mergeType!==1&&t.mergeType!==2)if(X(t.mergeType)&&t.mergeType.trim()==="1")t.mergeType=1;else if(X(t.mergeType)&&t.mergeType.trim()==="2")t.mergeType=2;else throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof t.mergeType}", equal to ${JSON.stringify(t.mergeType,null,4)}`);this.opts=t,this.ranges=[]}add(e,t,r){if(e==null&&t==null)return;if(C(e)&&!C(t)){if(Array.isArray(e)){if(e.length){if(e.some(n=>Array.isArray(n))){e.forEach(n=>{Array.isArray(n)&&this.add(...n)});return}e.length&&V(+e[0])&&V(+e[1])&&this.add(...e)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(e,null,0)}) but second-one, "to" is not (${JSON.stringify(t,null,0)})`)}else if(!C(e)&&C(t))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(t,null,0)}) but first-one, "from" is not (${JSON.stringify(e,null,0)})`);let i=+e,o=+t;if(V(r)&&(r=String(r)),V(i)&&V(o)){if(C(r)&&!X(r)&&!V(r))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof r}, equal to:
${JSON.stringify(r,null,4)}`);if(C(this.ranges)&&Array.isArray(this.last())&&i===this.last()[1]){if(this.last()[1]=o,this.last()[2],this.last()[2]!==null&&C(r)){let n=this.last()[2]&&this.last()[2].length>0&&(!this.opts||!this.opts.mergeType||this.opts.mergeType===1)?`${this.last()[2]}${r}`:r;this.opts.limitToBeAddedWhitespace&&(n=pe(n,this.opts.limitLinebreaksCount)),X(n)&&!n.length||(this.last()[2]=n)}}else{this.ranges||(this.ranges=[]);let n=r!==void 0&&!(X(r)&&!r.length)?[i,o,r&&this.opts.limitToBeAddedWhitespace?pe(r,this.opts.limitLinebreaksCount):r]:[i,o];this.ranges.push(n)}}else throw V(i)&&i>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof o}" equal to: ${JSON.stringify(o,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof i}" equal to: ${JSON.stringify(i,null,4)}`)}push(e,t,r){this.add(e,t,r)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=oi(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(e=>C(e[2])?[e[0],e[1],pe(e[2],this.opts.limitLinebreaksCount)]:e):this.ranges):null}wipe(){this.ranges=[]}replace(e){if(Array.isArray(e)&&e.length)if(Array.isArray(e[0])&&V(e[0][0]))this.ranges=Array.from(e);else throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(e[0],null,4)} should be an array and its first element should be an integer, a string index.`);else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};var fi={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function Fe(e,t){if(!Array.isArray(e)||!e.length)return e;let r=$($({},fi),t),i,o;if(r.strictlyTwoElementsInRangeArrays&&!e.every((s,h)=>!Array.isArray(s)||s.length!==2?(i=h,o=s.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${i}th range (${JSON.stringify(e[i],null,4)}) has not two but ${o} elements!`);if(!e.every((s,h)=>!Array.isArray(s)||!Number.isInteger(s[0])||s[0]<0||!Number.isInteger(s[1])||s[1]<0?(i=h,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${i}th range (${JSON.stringify(e[i],null,4)}) does not consist of only natural numbers!`);let n=e.length**2,l=0;return Array.from(e).sort((s,h)=>(r.progressFn&&(l+=1,r.progressFn(Math.floor(l*100/n))),s[0]===h[0]?s[1]<h[1]?-1:s[1]>h[1]?1:0:s[0]<h[0]?-1:1))}var Yt={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function Xt(e,t){function r(a){return a&&typeof a=="object"&&!Array.isArray(a)}if(!Array.isArray(e)||!e.length)return null;let i;if(t)if(r(t)){if(i=$($({},Yt),t),i.progressFn&&r(i.progressFn)&&!Object.keys(i.progressFn).length)i.progressFn=null;else if(i.progressFn&&typeof i.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof i.progressFn}", equal to ${JSON.stringify(i.progressFn,null,4)}`);if(![1,2,"1","2"].includes(i.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof i.mergeType}", equal to ${JSON.stringify(i.mergeType,null,4)}`);if(typeof i.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof i.joinRangesThatTouchEdges}", equal to ${JSON.stringify(i.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(t,null,4)} (type ${typeof t})`);else i=$({},Yt);let o=e.filter(a=>Array.isArray(a)).map(a=>[...a]).filter(a=>a[2]!==void 0||a[0]!==a[1]),n,l,s;i.progressFn?n=Fe(o,{progressFn:a=>{s=Math.floor(a/5),s!==l&&(l=s,i.progressFn(s))}}):n=Fe(o);let h=n.length-1;for(let a=h;a>0;a--)i.progressFn&&(s=Math.floor((1-a/h)*78)+21,s!==l&&s>l&&(l=s,i.progressFn(s))),(n[a][0]<=n[a-1][0]||!i.joinRangesThatTouchEdges&&n[a][0]<n[a-1][1]||i.joinRangesThatTouchEdges&&n[a][0]<=n[a-1][1])&&(n[a-1][0]=Math.min(n[a][0],n[a-1][0]),n[a-1][1]=Math.max(n[a][1],n[a-1][1]),n[a][2]!==void 0&&(n[a-1][0]>=n[a][0]||n[a-1][1]<=n[a][1])&&n[a-1][2]!==null&&(n[a][2]===null&&n[a-1][2]!==null?n[a-1][2]=null:n[a-1][2]!=null?+i.mergeType==2&&n[a-1][0]===n[a][0]?n[a-1][2]=n[a][2]:n[a-1][2]+=n[a][2]:n[a-1][2]=n[a][2]),n.splice(a,1),a=n.length);return n.length?n:null}var ui=!0,ke="Invariant failed";function Zt(e,t){if(!e){if(ui)throw new Error(ke);var r=typeof t=="function"?t():t,i=r?ke+": "+r:ke;throw new Error(i)}}function L(e,t,r){let i=0,o=0;if(arguments.length===0)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(typeof e!="string")throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(t&&!Array.isArray(t))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof t}, equal to: ${JSON.stringify(t,null,4)}`);if(r&&typeof r!="function")throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof r}, equal to: ${JSON.stringify(r,null,4)}`);if(!t||!t.filter(g=>g).length)return e;let n;Array.isArray(t)&&Number.isInteger(t[0])&&Number.isInteger(t[1])?n=[Array.from(t)]:n=Array.from(t);let l=n.length,s=0;n.filter(g=>g).forEach((g,c)=>{if(r&&(i=Math.floor(s/l*10),i!==o&&(o=i,r(i))),!Array.isArray(g))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${c}th element not an array: ${JSON.stringify(g,null,4)}, which is ${typeof g}`);if(!Number.isInteger(g[0])){if(!Number.isInteger(+g[0])||+g[0]<0)throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${c}th element, array ${JSON.stringify(g,null,0)}. Its first element is not an integer, string index, but ${typeof g[0]}, equal to: ${JSON.stringify(g[0],null,4)}.`);n[c][0]=+n[c][0]}if(!Number.isInteger(g[1])){if(!Number.isInteger(+g[1])||+g[1]<0)throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${c}th element, array ${JSON.stringify(g,null,0)}. Its second element is not an integer, string index, but ${typeof g[1]}, equal to: ${JSON.stringify(g[1],null,4)}.`);n[c][1]=+n[c][1]}s+=1});let h=Xt(n,{progressFn:g=>{r&&(i=10+Math.floor(g/10),i!==o&&(o=i,r(i)))}});Zt(h);let a=h.length;if(a>0){let g=e.slice(h[a-1][1]);e=h.reduce((c,T,m,u)=>{r&&(i=20+Math.floor(m/a*80),i!==o&&(o=i,r(i)));let y=m===0?0:u[m-1][1],d=u[m][0];return`${c}${e.slice(y,d)}${u[m][2]||""}`},""),e+=g}return e}var Qt=U(Ve(),1);var gi={classicTrim:!1,cr:!1,lf:!1,tab:!1,space:!0,nbsp:!1};function Q(e,t){if(typeof e!="string")throw new Error(`string-trim-spaces-only: [THROW_ID_01] input must be string! It was given as ${typeof e}, equal to:
${JSON.stringify(e,null,4)}`);let r=$($({},gi),t);function i(l){return r.classicTrim&&!l.trim()||!r.classicTrim&&(r.space&&l===" "||r.cr&&l==="\r"||r.lf&&l===`
`||r.tab&&l==="	"||r.nbsp&&l==="\xA0")}let o,n;if(e.length){if(i(e[0]))for(let l=0,s=e.length;l<s;l++){if(!i(e[l])){o=l;break}if(l===e.length-1)return{res:"",ranges:[[0,e.length]]}}if(i(e[e.length-1])){for(let l=e.length;l--;)if(!i(e[l])){n=l+1;break}}return o?n?{res:e.slice(o,n),ranges:[[0,o],[n,e.length]]}:{res:e.slice(o),ranges:[[0,o]]}:n?{res:e.slice(0,n),ranges:[[n,e.length]]}:{res:e,ranges:[]}}return{res:"",ranges:[]}}var ci={heads:["{{"],tails:["}}"]};function er(e,t){let r=Object.prototype.hasOwnProperty;if(e===void 0)throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_01] The input is missing!");if(typeof e!="string")return e;if(t&&!(0,Qt.default)(t))throw new Error(`string-remove-duplicate-heads-tails: [THROW_ID_03] The given options are not a plain object but ${typeof t}!`);let i=$({},t);if(i&&r.call(i,"heads"))if(I(i.heads).every(y=>typeof y=="string"||Array.isArray(y)))typeof i.heads=="string"&&(i.heads=I(i.heads));else throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_04] The opts.heads contains elements which are not string-type!");if(i&&r.call(i,"tails"))if(I(i.tails).every(y=>typeof y=="string"||Array.isArray(y)))typeof i.tails=="string"&&(i.tails=I(i.tails));else throw new Error("string-remove-duplicate-heads-tails: [THROW_ID_05] The opts.tails contains elements which are not string-type!");let o=Q(e).res;if(o.length===0)return e;e=o;let n=$($({},ci),i);n.heads=n.heads.map(y=>y.trim()),n.tails=n.tails.map(y=>y.trim());let l=!1,s=!1,h=new Z({limitToBeAddedWhitespace:!0}),a=new Z({limitToBeAddedWhitespace:!0}),g=!0,c=!0,T="";function m(y,d){let f;return W(y,0,d.heads,{trimBeforeMatching:!0,cb:(p,w,b)=>(f=b,!0)})&&W(y,f,d.tails,{trimBeforeMatching:!0,cb:(p,w,b)=>(f=b,!0)})?y.slice(f):y}for(;e!==m(e,n);)e=Q(m(e,n)).res;function u(y,d){let f;return!k(y,y.length-1,d.tails,{trimBeforeMatching:!0,cb:(p,w,b)=>(f=b,!0)})||!f?y:k(y,f,d.heads,{trimBeforeMatching:!0,cb:(p,w,b)=>(f=b,!0)})?y.slice(0,f+1):y}for(;e!==u(e,n);)e=Q(u(e,n)).res;if(!n.heads.length||!W(e,0,n.heads,{trimBeforeMatching:!0})||!n.tails.length||!k(e,e.length-1,n.tails,{trimBeforeMatching:!0}))return Q(e).res;for(let y=0,d=e.length;y<d;y++)if(e[y].trim()!==""){let f;if(W(e,y,n.heads,{trimBeforeMatching:!0,cb:(p,w,b)=>(f=b,!0)})&&f){c=!0,g&&(g=!0);let p;W(e,f,n.tails,{trimBeforeMatching:!0,cb:(w,b,O)=>(p=O,!0)})&&h.push(y,p),a.current()&&l&&T!=="tails"&&h.push(a.current()),l||a.current()&&(h.push(a.current()),a.wipe()),a.push(y,f),T="heads",y=f-1;continue}if(W(e,y,n.tails,{trimBeforeMatching:!0,cb:(p,w,b)=>(f=Number.isInteger(b)?b:e.length,!0)})&&f){c=!0,g?(T==="heads"&&a.wipe(),g=!1):a.push(y,f),T="tails",y=f-1;continue}g&&(g=!0),c&&!l?(l=!0,c=!1):c&&!s?(s=!0,g=!0,c=!1,T==="heads"&&a.wipe()):c&&s&&a.wipe()}return a.current()&&h.push(a.current()),h.current()?L(e,h.current()).trim():e.trim()}var tr="11.0.10";var pi=tr,di=Object.prototype.hasOwnProperty,rr={heads:"%%_",tails:"_%%",headsNoWrap:"%%-",tailsNoWrap:"-%%",lookForDataContainers:!0,dataContainerIdentifierTails:"_data",wrapHeadsWith:"",wrapTailsWith:"",dontWrapVars:[],preventDoubleWrapping:!0,wrapGlobalFlipSwitch:!0,noSingleMarkers:!1,resolveToBoolIfAnyValuesContainBool:!0,resolveToFalseIfAnyValuesContainBool:!0,throwWhenNonStringInsertedInString:!1,allowUnresolved:!1};function A(e){return typeof e=="string"}function yi(e){return typeof e=="number"}function Le(e){return typeof e=="boolean"}function de(e){return e===null}function ee(e){return e&&typeof e=="object"&&!Array.isArray(e)}function mi(e){return e!=null}function _(e){return A(e)?e.trim():e}function wi(e){if(typeof e=="string"&&e.length>0&&e.indexOf(".")!==-1){for(let t=0,r=e.length;t<r;t++)if(e[t]===".")return e.slice(0,t)}return e}function bi(e){if(typeof e=="string"&&e.length>0&&e.indexOf(".")!==-1){for(let t=0,r=e.length;t<r;t++)if(e[t]===".")return e.slice(t+1)}return e}function nr(e){if(typeof e=="string"&&e.length>0&&e.indexOf(".")!==-1){for(let t=e.length;t--;)if(e[t]===".")return e.slice(0,t)}return e}function ir(e){if(typeof e=="string"&&e.length>0&&e.indexOf(".")!==-1){for(let t=e.length;t--;)if(e[t]===".")return e.slice(t+1)}return e}function qe(e,t){return typeof e!="string"||!e.trim()?!1:!!(e.includes(t.heads)||e.includes(t.tails)||A(t.headsNoWrap)&&t.headsNoWrap.length>0&&e.includes(t.headsNoWrap)||A(t.tailsNoWrap)&&t.tailsNoWrap.length>0&&e.includes(t.tailsNoWrap))}function Ti(e,t,r){let i,o;return typeof e=="string"&&e.length>0&&W(e,0,t,{trimBeforeMatching:!0,cb:(n,l,s)=>(i=s,!0)})&&k(e,e.length-1,r,{trimBeforeMatching:!0,cb:(n,l,s)=>(o=+s+1,!0)})?e.slice(i,o):e}function sr(e,t,r=!1,i,o,n){if(t.wrapHeadsWith||(t.wrapHeadsWith=""),t.wrapTailsWith||(t.wrapTailsWith=""),A(e)&&!r&&t.wrapGlobalFlipSwitch&&!t.dontWrapVars.some(l=>ge(n,l))&&(!t.preventDoubleWrapping||t.preventDoubleWrapping&&A(e)&&!e.includes(t.wrapHeadsWith)&&!e.includes(t.wrapTailsWith)))return`${t.wrapHeadsWith}${e}${t.wrapTailsWith}`;if(r){if(!A(e))return e;let l=er(e,{heads:t.wrapHeadsWith,tails:t.wrapTailsWith});return A(l)?Ti(l,t.wrapHeadsWith,t.wrapTailsWith):l}return e}function $i(e,t,r,i){let o;if(r.indexOf(".")!==-1){let n=r,l=!0;if(i.lookForDataContainers&&typeof i.dataContainerIdentifierTails=="string"&&i.dataContainerIdentifierTails.length>0&&!n.endsWith(i.dataContainerIdentifierTails)){let s=D.default.get(e,n+i.dataContainerIdentifierTails);ee(s)&&D.default.get(s,t)&&(o=D.default.get(s,t),l=!1)}for(;l&&n.indexOf(".")!==-1;){if(n=nr(n),ir(n)===t)throw new Error(`json-variables/findValues(): [THROW_ID_20] While trying to resolve: "${t}" at path "${r}", we encountered a closed loop. The parent key "${ir(n)}" is called the same as the variable "${t}" we're looking for.`);if(i.lookForDataContainers&&typeof i.dataContainerIdentifierTails=="string"&&i.dataContainerIdentifierTails.length>0&&!n.endsWith(i.dataContainerIdentifierTails)){let s=D.default.get(e,n+i.dataContainerIdentifierTails);ee(s)&&D.default.get(s,t)&&(o=D.default.get(s,t),l=!1)}if(o===void 0){let s=D.default.get(e,n);ee(s)&&D.default.get(s,t)&&(o=D.default.get(s,t),l=!1)}}}if(o===void 0){let n=D.default.get(e,t);n!==void 0&&(o=n)}if(o===void 0)if(t.indexOf(".")===-1){let n=Be(e,t);if(n.length>0){for(let l=0,s=n.length;l<s;l++)if(A(n[l].val)||Le(n[l].val)||de(n[l].val)){o=n[l].val;break}else if(yi(n[l].val)){o=String(n[l].val);break}else if(Array.isArray(n[l].val)){o=n[l].val.join("");break}}}else{let n=Be(e,wi(t));if(n.length>0)for(let l=0,s=n.length;l<s;l++){let h=D.default.get(n[l].val,bi(t));h&&A(h)&&(o=h)}}return o}function ar(e,t,r,i,o=[]){if(o.includes(r)){let m="";if(o.length>1){let u=` \u2192
`;m=o.reduce((y,d,f)=>y+(f===0?"":u)+(d===r?"\u{1F4A5} ":"  ")+d,` Here's the path we travelled up until we hit the recursion:

`),m+=`${u}\u{1F4A5} ${r}`}throw new Error(`json-variables/resolveString(): [THROW_ID_19] While trying to resolve: "${t}" at path "${r}", we encountered a closed loop, the key is referencing itself."${m}`)}let n={},l=Array.from(o);l.push(r);let s=new Z;function h(m,u,y){for(let d=0,f=m.length;d<f;d++){let p=m[d],w=t.slice(p.headsEndAt,p.tailsStartAt);if(w.length===0)s.push(p.headsStartAt,p.tailsEndAt);else if(di.call(n,w)&&A(n[w]))s.push(p.headsStartAt,p.tailsEndAt,n[w]);else{let b=$i(e,w.trim(),r,i);if(b===void 0)if(i.allowUnresolved===!0)b="";else if(typeof i.allowUnresolved=="string")b=i.allowUnresolved;else throw new Error(`json-variables/processHeadsAndTails(): [THROW_ID_18] We couldn't find the value to resolve the variable ${t.slice(p.headsEndAt,p.tailsStartAt)}. We're at path: "${r}".`);if(!y&&i.throwWhenNonStringInsertedInString&&!A(b))throw new Error(`json-variables/processHeadsAndTails(): [THROW_ID_23] While resolving the variable ${t.slice(p.headsEndAt,p.tailsStartAt)} at path ${r}, it resolved into a non-string value, ${JSON.stringify(b,null,4)}. This is happening because options setting "throwWhenNonStringInsertedInString" is active (set to "true").`);if(Le(b)){if(i.resolveToBoolIfAnyValuesContainBool)return s.wipe(),i.resolveToFalseIfAnyValuesContainBool?!1:b;b=""}else{if(de(b)&&y)return s.wipe(),b;Array.isArray(b)?b=String(b.join("")):de(b)?b="":b=String(b)}let O=r.includes(".")?`${nr(r)}.${w}`:w;if(qe(b,i)){let E=sr(ar(e,b,O,i,l),i,u,l,O,w.trim());typeof E=="string"&&s.push(p.headsStartAt,p.tailsEndAt,E)}else{n[w]=b;let E=sr(b,i,u,l,O,w.trim());typeof E=="string"&&s.push(p.headsStartAt,p.tailsEndAt,E)}}}}let a;try{a=Pe(t,i.heads,i.tails,{source:"",throwWhenSomethingWrongIsDetected:!1})}catch(m){throw new Error(`json-variables/resolveString(): [THROW_ID_17] While trying to resolve string: "${t}" at path ${r}, something wrong with heads and tails was detected! Here's the internal error message:
${m}`)}let g=!1;a.length===1&&L(t,[[a[0].headsStartAt,a[0].tailsEndAt]]).trim()===""&&(g=!0);let c=h(a,!1,g);if(typeof c=="boolean"||c===null)return c;try{a=Pe(t,i.headsNoWrap,i.tailsNoWrap,{source:"",throwWhenSomethingWrongIsDetected:!1})}catch(m){throw new Error(`json-variables/resolveString(): [THROW_ID_22] While trying to resolve string: "${t}" at path ${r}, something wrong with no-wrap heads and no-wrap tails was detected! Here's the internal error message:
${m}`)}a.length===1&&L(t,[[a[0].headsStartAt,a[0].tailsEndAt]]).trim()===""&&(g=!0);let T=h(a,!0,g);return Le(T)||de(T)?T:(s==null?void 0:s.current())?L(t,s.current()):t}function vi(e,t){if(!arguments.length)throw new Error("json-variables/jVar(): [THROW_ID_01] Alas! Inputs are missing!");if(!ee(e))throw new TypeError(`json-variables/jVar(): [THROW_ID_02] Alas! The input must be a plain object! Currently it's: ${Array.isArray(e)?"array":typeof e}`);if(t&&!ee(t))throw new TypeError(`json-variables/jVar(): [THROW_ID_03] Alas! An Optional Options Object must be a plain object! Currently it's: ${Array.isArray(t)?"array":typeof t}`);let r=$($({},rr),t);r.dontWrapVars?Array.isArray(r.dontWrapVars)||(r.dontWrapVars=I(r.dontWrapVars)):r.dontWrapVars=[];let i,o;if(r.dontWrapVars.length>0&&!r.dontWrapVars.every((l,s)=>A(l)?!0:(i=l,o=s,!1)))throw new Error(`json-variables/jVar(): [THROW_ID_05] Alas! All variable names set in opts.dontWrapVars should be of a string type. Computer detected a value "${i}" at index ${o}, which is not string but ${Array.isArray(i)?"array":typeof i}!`);if(r.heads==="")throw new Error("json-variables/jVar(): [THROW_ID_06] Alas! opts.heads are empty!");if(r.tails==="")throw new Error("json-variables/jVar(): [THROW_ID_07] Alas! opts.tails are empty!");if(r.lookForDataContainers&&r.dataContainerIdentifierTails==="")throw new Error("json-variables/jVar(): [THROW_ID_08] Alas! opts.dataContainerIdentifierTails is empty!");if(r.heads===r.tails)throw new Error("json-variables/jVar(): [THROW_ID_09] Alas! opts.heads and opts.tails can't be equal!");if(r.heads===r.headsNoWrap)throw new Error("json-variables/jVar(): [THROW_ID_10] Alas! opts.heads and opts.headsNoWrap can't be equal!");if(r.tails===r.tailsNoWrap)throw new Error("json-variables/jVar(): [THROW_ID_11] Alas! opts.tails and opts.tailsNoWrap can't be equal!");if(r.headsNoWrap==="")throw new Error("json-variables/jVar(): [THROW_ID_12] Alas! opts.headsNoWrap is an empty string!");if(r.tailsNoWrap==="")throw new Error("json-variables/jVar(): [THROW_ID_13] Alas! opts.tailsNoWrap is an empty string!");if(r.headsNoWrap===r.tailsNoWrap)throw new Error("json-variables/jVar(): [THROW_ID_14] Alas! opts.headsNoWrap and opts.tailsNoWrap can't be equal!");let n;return ue(e,(l,s,h)=>{if(mi(s)&&qe(l,r))throw new Error(`json-variables/jVar(): [THROW_ID_15] Alas! Object keys can't contain variables!
Please check the following key: ${l}`);if(s!==void 0?n=s:n=l,n==="")return n;if(r.heads.length!==0&&_(n)===_(r.heads)||r.tails.length!==0&&_(n)===_(r.tails)||r.headsNoWrap.length!==0&&_(n)===_(r.headsNoWrap)||r.tailsNoWrap.length!==0&&_(n)===_(r.tailsNoWrap)){if(!r.noSingleMarkers)return n;throw new Error(`json-variables/jVar(): [THROW_ID_16] Alas! While processing the input, we stumbled upon ${_(n)} which is equal to ${_(n)===_(r.heads)?"heads":""}${_(n)===_(r.tails)?"tails":""}${A(r.headsNoWrap)&&_(n)===_(r.headsNoWrap)?"headsNoWrap":""}${A(r.tailsNoWrap)&&_(n)===_(r.tailsNoWrap)?"tailsNoWrap":""}. If you wouldn't have set opts.noSingleMarkers to "true" this error would not happen and computer would have left the current element (${_(n)}) alone`)}return A(n)&&qe(n,r)?ar(e,n,h.path,r):n})}return dr(Oi);})();
/**
 * @name arrayiffy-if-string
 * @fileoverview Put non-empty strings into arrays, turn empty-ones into empty arrays. Bypass everything else.
 * @version 4.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/arrayiffy-if-string/}
 */
/**
 * @name ast-get-values-by-key
 * @fileoverview Extract values and paths from AST by keys OR set them by keys
 * @version 4.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ast-get-values-by-key/}
 */
/**
 * @name ast-monkey-traverse
 * @fileoverview Utility library to traverse AST
 * @version 3.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ast-monkey-traverse/}
 */
/**
 * @name ast-monkey-util
 * @fileoverview Utility library of AST helper functions
 * @version 2.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ast-monkey-util/}
 */
/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 6.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */
/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 8.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */
/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 6.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 6.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */
/**
 * @name string-find-heads-tails
 * @fileoverview Finds where are arbitrary templating marker heads and tails located
 * @version 5.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-find-heads-tails/}
 */
/**
 * @name string-match-left-right
 * @fileoverview Match substrings on the left or right of a given index, ignoring whitespace
 * @version 8.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-match-left-right/}
 */
/**
 * @name string-remove-duplicate-heads-tails
 * @fileoverview Detect and (recursively) remove head and tail wrappings around the input string
 * @version 6.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-remove-duplicate-heads-tails/}
 */
/**
 * @name string-trim-spaces-only
 * @fileoverview Like String.trim() but you can choose granularly what to trim
 * @version 4.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-trim-spaces-only/}
 */
